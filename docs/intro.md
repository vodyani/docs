---
sidebar_position: 0
slug: intro
title: 介绍
---

**Vodyani 是一个专注于解决业务开发的 http 服务端开发脚手架。**

vodyani 基于 [nest.js](https://github.com/nestjs/nest) 开发，针对 node.js 服务端开发中的常见场景进行了易用的，友好的封装。

vodyani 的愿景是让 node.js 服务端开发者能够有一个基础的、拿来即用的脚手架。这个脚手架中将包含合理的层级设计、目录规范、编码规范（eslint）、单元测试等一系列工程化要素。

![](../static/img/vodyani-intro.png)

## vodyani 的底层依赖

Node.js 提供了 http 模块用来监听端口、处理请求响应，但是它的 api 过于原始，所以我们会包一层，在 express 这一层提供更多好用的 request、response 的 api，但这层没解决架构问题，要引入 MVC、IOC 等架构，需要再包一层，用 Egg.js、Midway.js、Nest.js 这种更上层的后端框架，其中 Nest.js 是最优秀的。
Nest.js 在和底层 http 平台的整合上做了特殊的设计，利用适配器模式，提供一层接口，让底层平台去适配，这样就可以灵活的切换不同的 http 平台了。

近年来，感谢 Node.js，JavaScript 已成为前端和后端应用程序的网络“通用语言”。这产生了令人敬畏的项目，如 Angular，React 和 Vue，它们提高了开发人员的工作效率，并能够构建快速，可测试和可扩展的前端应用程序。然而，虽然 Node（和服务器端 JavaScript ）存在大量优秀的库，帮助器和工具，但它们都没有有效地解决主要问题 - 架构。

Nest 提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。

## nest.js 解决了哪些问题？

nest.js 非常巧妙的结合了 TS 中的装饰器和反射机制，帮助我们将不同的类来自动注入到框架内部的 IoC 容器，把类的依赖，引用，初始化委托给了 nest.js 本身。

这样我们就降低了一些隐形的维护成本，比如我们不需要关心以往面向过程式的调用关系。不需要传递复杂的请求上下文，极大程度地降低了代码结构的复杂度，减少了开发人员的心智负担。

## nest.js 有哪些地方能做的更好？

在社区内总是将 nest.js 比作 Java 生态中的 Spring 框架，但是在这些场景中仍需要开发者自行解决：

1. nest.js 提供的 AOP 机制（过滤器，拦截器，管道，守卫等）只能在控制器(Controller)中使用，提供者(Provider)如果想加入切面机制只能通过开发者自己实现，如自定义装饰器、函数改造等。
2. 数据对象的传输，校验，转换如何处理？在控制器(Controller)中我们可以基于管道和拦截器的特性进行处理，但在提供者(Provider)中呢？
3. 层级如何划分？模块如何划分？模块之间如何进行组织？这些问题其实才是留给使用者最大的挑战。
4. 如何管理配置和配置中心？如何让配置只需要声明一次，就可以全局注入？
5. 如何结合远程配置中心，使得配置中心的数据更新后，自动重建服务中的客户端（如 MySQL、Redis）？

## 为什么使用 Vodyani?

### Vodyani 解决了哪些问题？

1. 在 nest.js v8.x 的基础上，针对层级和模块组织方式进行封装，并且引入了业务开发中一些常用的方法。

2. 基于 nest.js 推荐的 class-transformer + class-validator 进行封装，并提供易用的 [transformer](./advanced/transformer.md) 和 [validator](./advanced/validator.md) 模块，我们可以通过引入这两个模块中定义的装饰器或方法，对提供者提供 AOP 切面功能（转换、校验）

3. 开发了 [Ark](./advanced/ark.md) 配置管理模块，你可以通过定义本地文件 + 定义远程配置中心引入的方式，轻松的管理，读取，写入全局配置。并且 [Core](./advanced/core.md) 中提供了一个通用的客户端适配器接口，通过实现这个接口，你可以轻松的将客户端适配器注入到 Ark 的动态数据源中进行动态部署。

4. 开发了 [Dust](./advanced/dust.md) 线程管理模块，你可以通过注入线程池容器或者直接调用线程的方式，来轻松地管理本地线程。

5. 结合 nest.js + nest.js Swagger 封装和定义全局的数据对象，细分为 DTO/DO/VO 三层。分别对应 `输入`，`处理中`，`输出` 这三种数据处理状态。
 
## 版本规划与管理

1. Vodyani 的版本将始终跟随 nest.js 的 `major` 版本号进行迭代，除非 nest.js 不再进行维护。
2. Vodyani 的核心模块与脚手架将始终跟随 nest.js 的 `major` 版本号进行管理，开发者通过 [CLI 工具](./other/cli)进行依赖升级和管理。
